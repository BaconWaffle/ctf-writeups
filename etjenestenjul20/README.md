# Cybertalent CTF, julen 2020



E-tjenesten holdt enda en CTF i slutten av desember 2020. Formatet er det samme [som sist](../etjenesten20/README.md), men med et nytt oppdrag og nye utfordringer. FjorÃ¥rets oppgaver er ogsÃ¥ inkludert, men foruten et par utvalgte fra hjernetrim, sÃ¥ er ingen av oppgavene poenggivende. Det har ogsÃ¥ blitt gjort smÃ¥ endringer i oppgavene, som plassering av flagg pÃ¥ mer logiske steder, samt oppgradering til en kernel hvor man ikke kan bruke Dirty Cow.



## 1. Grunnleggende

Oppgave 1, 2, 3, 4 og 6 er helt like som forrige gang. Oppgave 5 er ny.



### 1.5_nettverk

```
SÃ¥ langt har oppgavene dreid seg om Ã¥ fÃ¥ tilgang til filer pÃ¥ en maskin hvor man allerede har tilgang. Dataangrep starter ofte ved at man mÃ¥ skaffe seg denne tilgangen ved Ã¥ utnytte en *nettverkstjeneste* som er tilgjengelig pÃ¥ internett.

I denne mappen ligger en server som, etter Ã¥ ha blitt startet, lytter pÃ¥ port `tcp/10015`. For Ã¥ fÃ¥ tak i flagget trenger du ikke overflows som i forrige oppgave, men du mÃ¥ vise at du behersker programmeringsferdigheter som Ã¥ hÃ¥ndtere flere samtidige tilkoblinger og konvertering av binÃ¦re data.
```

Vedlagt ligger det et `server`-program med setuid til `basic5`, og filen `FLAGG` som eies av `basic5`. MÃ¥let er Ã¥ starte opp `server`, og sÃ¥ koble til denne pÃ¥ port 10015 og fÃ¸lge instruksjonene som kommer. Oppgaven krever at man fÃ¸rst kobler til en "hoved-socket" som fÃ¥r instruksjonene, sÃ¥ ytterligere 10 sockets til som vil fÃ¥ hvert sitt tall. Hovedsocketen skal sende summen av dette tallet, representert som hexadecimalt, til serveren. Deretter vil man begynne Ã¥ fÃ¥ en melding tilbake, 1 byte om gangen, fordelt utover alle de 11 aktive socketene.

```bash
login@corax:~/1_grunnleggende/5_nettverk$ ./server &
[1] 59
Lytter pÃ¥ port 10015, koble til for videre instruksjoner.
login@corax:~/1_grunnleggende/5_nettverk$ python3 ~/client.py
Dette er en grunnleggende introduksjon til nettverksprogrammering.
NÃ¥r du har Ã¥pnet ti nye tilkoblinger til denne serveren vil du fÃ¥ videre instruksjoner pÃ¥ denne socketen.

Du vil nÃ¥ fÃ¥ tilsendt et 32-bits heltall i `network byte order` i hver av de ti andre sesjonene.
Summer alle, og send resultatet tilbake pÃ¥ denne socketen.
Det er mange mÃ¥ter Ã¥ konvertere data pÃ¥. En av dem er `struct.unpack`.

100156465
162151653
255831055
127387575
162544181
261113337
63687561
118566558
197303127
189649586
1638391098
[b'a\xa7\xdd:']
Neste melding sendes fordelt over de ti sesjonene.
For Ã¥ unngÃ¥ Ã¥ blokkere mens du leser kan du for eksempel bruke `select.select()` eller `socket.settimeout(0)`.

Husk at utf-8 kan ha multi-byte tegn ğŸ˜Š

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Gratulerer!                            â”‚
â”‚                                        â”‚
â”‚ Her er flagget:                        â”‚
â”‚                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    3b25a1b0721f2b884fe60351f7dd7c3f    â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

Den ferdige koden ligger in [client.py](client.py)



## 2. Oppdrag

Ã…rets oppdrag starter med en historie om en kidnapping og en fiktiv terror-organisasjon som er ute etter Ã¥ befri Antarktis. En av terroristene har blitt pÃ¥grepet, og vi har fÃ¥tt innholdet pÃ¥ hans mobiltelefon og noe trafikkdata utlevert. `INTREP.txt` nevner hva oppdraget gÃ¥r ut pÃ¥

```
PRIORITERINGANE VÃ…RE ER:

    (1) FRIGJEVA GISSELET ELLER GISSELA
    (2) IDENTIFISERA GISSELTAKARANE
    (3) HALDA FAST PÃ… NORSK SUVERENITET OVER DRONNING MAUD LAND
```



La oss starte med Ã¥ analysere beslaget.

`lt3000.apk` inneholder en Android-app, som terroristene tydeligvis har brukt til Ã¥ lagre ting og kommunisere. Det fÃ¸lger med en del data-filer som hÃ¸rer til denne, og vi skal undersÃ¸ke de i tur og orden:

`users.db` er en SQLite-database som inneholder noe informasjon om en bruker

````
1	hungry_hippo_123	Frank	Shorius	2034F6E32958647FDFF75D265B455EBF
````

hvor sistnevnte er en passord-hash. Enkelt Google-sÃ¸k sier at dette er en velkjent MD5-hash for passordet `secretpassword`.

`data.bin` ser ut til Ã¥ vÃ¦re ganske random, og lengden er delelig med 16 - enten av tilfeldigheter, eller fordi filen kryptert med en blockbasert algoritme som AES.

`files/!aW1wb3J0YW50X2xpbmtz`, `files/!c2hvcHBpbmdfbGlzdA==` etc. har base64-enkodede navn for "flag", "todo", "shopping_list" og "important_links" med et utropstegn foran. Alle filene har lengder og entropi som tilsier at de er krypterte med en block-cipher som AES.

Selve appen bestÃ¥r av flere komponenter, og hver av disse inneholder et flagg. APKen er delvis obfuskert, og har flere funksjoner gjemt i native libs, som gjÃ¸r at denne antageligvis er enklere Ã¥ reverse-engineere dynamisk enn statisk. Det er ogsÃ¥ noen sjekker for Ã¥ se etter emulerte miljÃ¸, hvor dekryptering blir stoppet om det detekteres noen form for emulering eller rooting.



### 2.1_beslag_1

I `Tuner`-modulen, sÃ¥ kan man hÃ¸re pÃ¥ ulike "radio"-kanaler. Disse er representert av mp3-filer inne i APKen. Ingen av disse er noe interessante. Det er ogsÃ¥ et felt hvor man kan taste inn brukernavn og passord, og hvis vi legger over `data.bin` fra beslaget over pÃ¥ telefonen/emulatoren, og sÃ¥ logger inn med `hungry_hippo_123` / `secretpassword` sÃ¥ vil det dukke opp en 7. kanal som leser opp et flagg: `london_calling`.

Jeg lÃ¸ste denne statisk, ved Ã¥ bruke upper-case MD5-hexdigest av `secretpassword` som passord i en pbkdf2_hmac-rutine, med saltet `saltpaamaten` og 0x10000 runder, samt dklen 0x100. De fÃ¸rste 16 bytene av filen er initialiseringsvektoren (IV) for AES i CBC-mode.

```python
def getKey(pw):
    return pbkdf2_hmac(
        hash_name = 'sha256',
        password = md5(pw).hexdigest().upper().encode(),
        salt = b"saltpaamaten",
        iterations = 0x10000,
        dklen = 0x100
    )

with open("flag.mp3", "wb") as fd:
    encdata = open("data.bin", "rb").read()
    iv = encdata[:16]
    enc = encdata[16:]
    key = getKey(b"secretpassword")
    aes = AES.new(key[:32], AES.MODE_CBC, iv=iv)
    fd.write(aes.decrypt(enc))
```



Ved levering kommer meldingen

```
Bra jobbet!
Det hadde vÃ¦rt praktisk om vi visste hvordan de har kommunisert.
```



### 2.1_beslag_2

`Chat`-modulen til appen kontakter `https://mobile.cybertalent.no/login`. Ved Ã¥ logge inn der med brukernavnet og passordet vi har, sÃ¥ blir vi sendt videre til `https://mobile.cybertalent.no/challenge` hvor det er en boks med et tilfeldig generert ord, og sÃ¥ skal vi skrive inn en respons. Dette ordet endrer seg ca. hvert 10. sekund, og ser ut til Ã¥ representere en TOTP (Timed One-Time Password), altsÃ¥ en slags tofaktor-tjeneste.

Hvis vi ser i den delvis dekompilerte APK-koden, sÃ¥ er det et native-lib som henter responsen for oss. Ved Ã¥ se nÃ¦rmere pÃ¥ dette biblioteket i IDA, sÃ¥ ser vi at det tar i bruk tiden, rundet av til nÃ¦rmeste 10 sekunder, og gjÃ¸r mange kalkulasjoner pÃ¥ den. Men en annen - mye viktigere - observasjon, er at nÃ¥r det sendes inn et forsÃ¸k pÃ¥ Ã¥ lÃ¸se en challenge, sÃ¥ ser responsen sÃ¥nn her ut:

```
{"corr":"b\'4581b488a5b4bb5aa5a4b7b75988b9b4bb8b888a825588b6b6b4bb\'","error":"Bad response code"}
```

altsÃ¥ sier de "Nei, det var feil. Det skulle ha vÃ¦rt dette: ..." Siden kodene er gyldige i hele 10 sekunder, sÃ¥ er det derfor rimelig rett-fram Ã¥ bare vente til challenge endrer seg, gjette noe, sÃ¥ skrive inn det korrekte svaret som vi fÃ¥r i responsen.

```python
from requests import session
s = session()
s.get("https://mobile.cybertalent.no/")
r = s.post("https://mobile.cybertalent.no/login", json={"user": "hungry_hippo_123", "pass": "secretpassword"})
r = s.post("https://mobile.cybertalent.no/getchall", json={})
r = s.post("https://mobile.cybertalent.no/challenge", json={"response": "aa"})
correct = r.json()['corr']
r = s.post("https://mobile.cybertalent.no/challenge", json={"response": correct})
print(r.content)
```

(Litt senere ut i konkurransen sÃ¥ forsvant dette "corr"-feltet fra responsen, sÃ¥ spÃ¸rs om dette ikke var meningen. I sÃ¥ fall mÃ¥ funksjonen i native-lib reverse-engineeres.)

Tastes denne inn, kommer en ny melding

![image-20201222195348159](image-20201222195348159.png)



Ved Ã¥ gÃ¥ til `https://mobile.cybertalent.no/chat?token=8bae3bb58cfe04c98a4d` innen 10 sekunder, sÃ¥ fÃ¥r vi ut en [chatlog](chat.txt) som inneholder et flagg og noe viktig informasjon:

- De har alle vÃ¦rt pÃ¥ samme flight, siden det gÃ¥r svÃ¦rt fÃ¥ fly til destinasjonen deres per Ã¥r, men de har ulike bookinger. Vi fÃ¥r vite booking-nummeret til Frank Shorius.
- De har en bakdÃ¸r pÃ¥ en server, hvor brukernavnene er pÃ¥ formatet `<3 bokstaver av fornavn><lengde pÃ¥ nick><etternavn>` uten Ã¥ fjerne store bokstaver.

Flagget gir meldingen

```
Flott! NÃ¥ vet vi litt mer om gisseltakerne.
Ligger det noen interessante filer eller tekniske spor her ogsÃ¥?
```



### 2.1_beslag_3

Siste flagg finnes i `Vault`-delen av appen. Denne var litt vrien Ã¥ lÃ¸ste statisk, men ser ut til Ã¥ vÃ¦re ganske enkel med en dynamisk approach.

Vault lar deg skrive inn smÃ¥ tekstbiter med en overskrift. Disse kan krypteres ved Ã¥ sette en 4-sifret PIN-kode og trykke pÃ¥ `Lock`. Da krypteres de originale filene med en nÃ¸kkel utledet av PIN-koden, og lagres i formatet `!<base64(originalnavn)>`. I `VaultActivity.xml` fra beslaget, finner vi ogsÃ¥ en entry `<string name="pin_hash">BSzN6uy2dDcolImpMKxffg==</string>` som ser ut til Ã¥ brukes til Ã¥ sammenligne inntastet PIN mot riktig PIN; altsÃ¥ den som ble brukt til Ã¥ kryptere notatene vi ser i beslaget.

Det er mange steg pÃ¥ veien for Ã¥ utlede hvordan krypteringen fungerer. Algoritmene er de samme som for `data.bin` i `2.1_beslag_1`, men det er noe ekstra som skjer i tillegg. Filen `https://mobile.cybertalent.no/xtra` lastes ned, og native-funksjonen `undo()` blir kalt pÃ¥ dataene som lastes ned, slik at filen blir en gyldig DEX-fil. Deretter lastes denne inn som en dynamisk klasse. Etter Ã¥ ha reverset `undo()` sÃ¥ ser den ca. sÃ¥nn her ut

```python
i = 0
j = 0
k = 0

v8 = open("xtra","rb").read()
v7 = len(v8)
v9 = [0]*len(v8)

while True:
  v14 = j + (v7 >> 1)
  v15 = i & 1
  if ( not (i & 1) ):
    v14 = k
  k += v15 ^ 1;
  j += v15;
  v9[i] = v8[v14]
  i += 1
  if v7 == i:
    break

with open("xtra.undo.dex","wb") as fd:
    fd.write(bytes(v9))
```



Denne ekstra-klassen implementerer funksjonen `getData(String str)`, som ender opp med Ã¥ hashe `str+"y_so_salty"` med MD5 og SHA256 (individuelt) og sÃ¥ returnere begge digestene etter hverandre. MD5-delen brukes til Ã¥ sammenligne mot `pin_hash`, mens SHA256-delen brukes som nÃ¸kkel for Ã¥ dekryptere notatene.

```python
def getData(s):
    if type(s) == str:
        s = s.encode()
    s += b"y_so_salty"
    h1 = md5(s).digest()
    h2 = sha256(s).digest()
    return (h1 + h2)
```

med denne funksjonen pÃ¥ plass, og viten om at vi skal bare bruke sha256-delen nÃ¥r vi dekrypterer, sÃ¥ kan vi endelig lese ut filene:

```python
for file in os.listdir("files"):
    key = getKey(getData(pin)[16:48])
    encdata = open(f"files/{file}","rb").read()
    iv = encdata[:16]
    enc = encdata[16:]
    aes = AES.new(key[:32], AES.MODE_CBC, iv=iv)
    dec = aes.decrypt(enc)
    print(f"~~~{b64decode(file).decode()}~~~")
    print(unpad(dec, AES.block_size).decode().rstrip())
    print(f"~~~~~~~~~\n")
```

som gir outputen

```
Found pin! 5693
~~~important_links~~~
Hidden service URL:
http://fileserver/files/onion_name.txt

Scada client binary:
http://fileserver/files/0823...
Rembember this only works on the internal network, not from the outside.
~~~~~~~~~

~~~shopping_list~~~
1 Milk
1 Bread
6 Eggs
1000 rounds 7.76mm
10 HE grenades
4 Yoghurt
1 Butter
~~~~~~~~~

~~~todo~~~
Buy xmas presents
Find an xmas tree
Order airline tickets
~~~~~~~~~

~~~flag~~~
d025...
~~~~~~~~~

```



Siste del tok veldig lang tid, ettersom all den relevante koden ikke kunne bli dekompilert skikkelig av jadx. Andre decompilere bruker `dex2jar` internt, og dette verktÃ¸yet feilet fullstendig pÃ¥ den utleverte APK-filen, noe som gjorde at mange klasser rett og slett bare forsvant. Her mÃ¥tte jeg manuelt lese SMALI-kode og pusle sammen hva som skjedde pÃ¥ egenhÃ¥nd. Om jeg hadde tatt i bruk instrumentering som Frida, sÃ¥ hadde nok dette vÃ¦rt redusert til Ã¥ faktisk bare finne en workaround for emuleringssjekken og sÃ¥ testet alle PIN-kodene i rekkefÃ¸lge.

Ut av denne fÃ¥r vi uansett to viktige filer pÃ¥ filserveren; en fil med onion-URL til et Scada-system (hvor vi umiddelbart finner flagg 2.3 i JS console) og en binary som sender merkelige meldinger til oppgitt host/port i argv[1] og argv[2]. NÃ¥r vi leverer flagget fÃ¥r vi enda et hint

```
Kanskje det ligger noen interessante filer her?
```



### 2.2_seatheworld

I PCAP-filen er det noe DNS-data og en webrequest mot domenet `seatheworld.tld`. Vi prÃ¸ver oss pÃ¥ en freidig DNS Zone Transfer:

```
dig axfr seatheworld.tld @ns1.seatheworld.tld
; <<>> DiG 9.11.5-P4-5.1+deb10u2-Debian <<>> axfr seatheworld.tld @ns1.seatheworld.tld
;; global options: +cmd
seatheworld.tld.        600     IN      SOA     ns1.seatheworld.tld. ns1.seatheworld.tld. 12345678 1200 180 1209600 600
seatheworld.tld.        600     IN      NS      ns1.seatheworld.tld.
seatheworld.tld.        600     IN      MX      10 mail.seatheworld.tld.
_flagg.nusse.seatheworld.tld. 600 IN    TXT     "0825fac...."
mail.seatheworld.tld.   600     IN      CNAME   www.seatheworld.tld.
seatheworld.tld.        600     IN      A       10.0.114.50
nusse.seatheworld.tld.  600     IN      A       10.0.114.43
ns1.seatheworld.tld.    600     IN      A       10.0.114.61
www.seatheworld.tld.    600     IN      A       10.0.114.50
seatheworld.tld.        600     IN      SOA     ns1.seatheworld.tld. ns1.seatheworld.tld. 12345678 1200 180 1209600 600  
```

og finner et flagg i TXT, med enda et hint etter innlevering

```
Bra jobbet!
Hva kan det vÃ¦re denne maskinen brukes til?
```



### 2.2_seatheworld_aksess

Mye scanning av frontenden `seatheworld.tld`, tyder pÃ¥ at det ikke er noe Ã¥ finne der. Det er bare port 80 som svarer, og det er bare en statisk webside som serveres tilbake. Dirbusting fÃ¸rer ikke til et eneste funn. `nusse.seatheworld.tld` kjÃ¸rer derimot FTP, SSH, Telnet og HTTPd. Banner fra alle tjenestene tyder pÃ¥ at dette er IBM z/OS, og en svÃ¦rt gammel utgivelse av denne. Etter mye lesing pÃ¥ nett, sÃ¥ fikk jeg brukt `nmap` til Ã¥ enumerere brukernavn og en del annet pÃ¥ terminal (Telnet)-tjenesten. Blant annet kan vi logge pÃ¥ med "USER/USER" eller "IBMUSER/SYS1", hvor sistnevnte er en slags superbruker. For Ã¥ kommunisere med terminalen, har Corax preinstallert mange python-biblioteker og kommandolinjeverktÃ¸y, og jeg falt pÃ¥ `c3270`.

```
c3270 nusse.seatheworld.tld
LOGON IBMUSER
(passord: SYS1)
```

![image-20201222202356094](image-20201222202356094.png)



Flagget er altsÃ¥ `RETRO_IS_THE_NEW_MODERN`, og under stÃ¥r instruksjoner pÃ¥ hvordan vi kan starte booking-applikasjonen.

```
Navn pÃ¥ gisseltakerne burde vÃ¦re tilgjengelig et sted pÃ¥ denne stormaskinen.
```



### 2.2_seatheworld_booking

![image-20201222202602128](image-20201222202602128.png)



NÃ¥r vi starter booking-systemet, sÃ¥ dukker det opp en melding om at flagget ikke kan printes, fordi funksjonen er avskrudd. Dette hinter ganske sterkt mot at vi skal finne en mÃ¥te Ã¥ skru pÃ¥ igjen denne funksjonaliteten. MÃ¥let med booking-deloppgaven er uansett Ã¥ finne navnet pÃ¥ terroristene, sÃ¥ dette flagget fÃ¥r vente litt.

Jeg kjÃ¸rte fÃ¸rst `LISTC` (utefor booking) for Ã¥ fÃ¥ en liste over entries, og noterte meg ned et par interessante:

- `IBMUSER.SEATW.BOOKINGS`
- `IBMUSER.SEATW.LOAD`
- `IBMUSER.SEATW.SRC`
- `IBMUSER.SEATW.SRC(CIPHER)`

Deretter ga jeg brukeren `USER` tilgang til Ã¥ lese disse via `PERMIT 'IBMUSER.SEATW.BOOKINGS' ID(USER) ACCESS(READ)` og tilsvarende for de andre. Derfra kunne jeg logge inn som `USER` via FTP (`IBMUSER` hadde ikke tilgang til FTP) og laste de ned (CD .. -> CD IBMUSER.SEATW -> get BOOKINGS).

Inne i SRC lÃ¥ det 3 entries: 

- `C` inneholder C-kode for booking-programmet.
- `JCL` inneholder noe metadata etter kompilering, eller noe i den dur.
- `CIPHER` inneholder et kryptert flagg. Dette referes til i `C`.

I tillegg lastet jeg ned `BOOKINGS` rett fra `IBMUSER.SEATW`. Alle filene mÃ¥ dekodes som EBCDIC, siden det er tekst-enkodingen IBM bruker.

Ut fra `BOOKINGS` kan vi sÃ¸ke opp Frank Shorius, eller bruke referansenummeret vi sÃ¥ i chatloggen fra `2.1_beslag_2` for Ã¥ finne flighten

`WJWQX AMS 2020-12-14 18:20 TXA 2020-12-14 22:40`

Ved Ã¥ sÃ¸ke etter denne finner vi 3 personer til, og alle disse er gyldige som flagg. I nevnte chatlog kunne vi ogsÃ¥ lÃ¦re at det fantes en bakdÃ¸r til scada-serveren, og reglene for hvordan brukernavn genereres. Via nmap kan vi lete etter denne bakdÃ¸ren, og finner den til slutt pÃ¥ hosten `scada` pÃ¥ port 1338, hvor det spÃ¸rres om "Username: " nÃ¥r vi kobler til. Ved Ã¥ korrelere lengde pÃ¥ brukernavn fra chatloggen, navnene fra bookingen, og gyldige inputs til bakdÃ¸ren, kan vi sette sammen en liste over terroristenes bookingreferanse, navn, nick og brukernavn til bakdÃ¸ren:

```
UHKVP AMS 2020-12-14 18:20 TXA 2020-12-14 22:40
DILLIAN CRUISE
B4tCracK
Dil8Cruise

WJWQX AMS 2020-12-14 18:20 TXA 2020-12-14 22:40
FRANK SHORIUS
hungry_hippo_123
Fra16Shorius

WTHHX AMS 2020-12-14 18:20 TXA 2020-12-14 22:40
JOE FARNABY
RADAR
Joe5Farnaby

Y6MY AMS 2020-12-14 18:20 TXA 2020-12-14 22:40
EIREEN FARNABY
eireen89
Eir8Farnaby
```

Merk at `Fra16Shorius` kun gir `User access revoked..` nÃ¥r vi forsÃ¸ker Ã¥ logge inn mot bakdÃ¸ren med det brukernavnet.

Det er ogsÃ¥ et Skype-nummer i MOTD ved innlogging til terminaltjenesten, og en alternativ mÃ¥te Ã¥ lÃ¸se `booking` pÃ¥ er Ã¥ ringe disse og overbevise de om Ã¥ finne booking-dataene for deg. Da fÃ¥r man derimot ikke lÃ¸st `ekstra`-oppgaven.



### 2.2_seatheworld_ekstra

Flagget som ikke printes pga. "compile time option" er interessant. NÃ¥ har jeg en form for C-kode, bare med altfor mye whitespace og en del korrupterte bytes her og der. Men det er nok til Ã¥ lese fÃ¸lgende (etter mye opprydning):

```c
void print_flag()
{
    char buf[512];
    FILE * fd = fopen("IBMUSER.SEATW.SRC(CIPHER)", "r");
    size_t i, n = fread(buf, 1, 32, fd);
    fclose(fd);                              
    buf[32] = 0;                             
    for (i = 0; i < n; i++)                      
        buf[i] = buf[i] ^ 17;
    printf("\n***********************************************"
           "\n FLAG: %s"
           "\n***********************************************\n\n", buf);
}
```

AltsÃ¥ leses entryen `CIPHER`, den XORes med 17, og sÃ¥ printes det ut. Vi har allerede hentet ut CIPHER, men sÃ¥ var det denne EBCDIC-enkodingen da... Litt dekoding senere sÃ¥ har vi den:

```python
>>> import ebcdic
>>> a=open("CIPHER","rb").read()
>>> bxor(a,bytes([17]*len(a))).decode('cp1142')
'c0da14705d80.....cÃ©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©Ã©' #(Sensurert)
```

```
Gratulerer! Du har utvist grunnleggende kunnskap om IBM stormaskiner.
Det er behov for kunnskap om en rekke forskjellige systemer i en jobb hos oss,
og evnen til Ã¥ sette seg inn i nye (og gamle!) ting er viktig.

En stor takk til IBM Norge som lot oss benytte z/OS for Ã¥rets CTF!
```



### 2.3_onion

Det er mulig Ã¥ `nmap`-e seg til dette flagget ganske tidlig, men jeg dumpet fÃ¸rst over det nÃ¥r jeg lÃ¸ste notatet i beslag 3. Dette pekte mot `http://fileserver/files/onion_name.txt`, som inneholder navnet pÃ¥ en TOR-server man kan aksessere for Ã¥ se en oversikt over et slags fengsel med  dÃ¸rer som gÃ¥r opp og igjen.

![image-20201222232550177](image-20201222232550177.png)



Nettsiden setter opp en websocket og begynner Ã¥ abonnere pÃ¥ oppdateringer fra systemet. Oppdateringene er en fullstendig tilstand over alle dÃ¸rene og detektorene i fengselet. RÃ¸de dÃ¸rer er lukket og lÃ¥st, gule er opplÃ¥st (men lukket) og grÃ¸nn er opplÃ¥st og Ã¥pnet. De store, rÃ¸de feltene er detektorer som er trigget, og betyr egentlig bare at det er noen (eller noe?) i det rommet for Ã¸yeblikket.

I JS console fÃ¥r vi fÃ¸lgende hint og et flagg:

```
PRO TIP: In case the TOR connection is unstable - you can access this via the hostname 'scada' internally
Here is a flag: b4ba...
```

Vi leverer flagget og fÃ¥r en beskjed:

```
Du har fÃ¥tt tilgang til gisseltakerenes bakdÃ¸r inn i styringssystemet. Klarer du Ã¥ styre systemet selv?
```



### 2.3_scada_aksess

Vi skal Ã¥penbart styre dÃ¸rene. Vi har en bakdÃ¸r via de hemmelige brukernavnene. Vi plukker et av brukernavnene pÃ¥ mÃ¥fÃ¥ og forsÃ¸ker Ã¥ logge inn:

```
login@corax:~$ nc scada 1338
Username: Dil8Cruise
We have now sent a login PIN to you via SMS
Enter PIN: 1234
..the provided PIN was not correct.
..the provided PIN was not correct.
3214
..the provided PIN was not correct.
..the provided PIN was not correct.
..the provided PIN was not correct.
..the provided PIN was not correct.
```



Brukernavn var altsÃ¥ ikke nok. Vi mÃ¥ ha en PIN ogsÃ¥. Ettersom vi har gjort alle oppgavene hittil, og ikke hÃ¸rt noe om et mobilnummer noe sted, er det sannsynlig at vi skal prÃ¸ve Ã¥ brute-force denne. Det er derimot noe veldig merkelig med tilbakemeldingene vi fÃ¥r, sÃ¥ det er ikke rett-fram Ã¥ scripte prosessen pÃ¥ en stabil mÃ¥te. Antall feilmeldinger varierer nemlig veldig, og av og til henger ting seg opp. Vi finner til slutt ut at det er maksimalt 256 forsÃ¸k pÃ¥ Ã¥ taste inn PIN fÃ¸r vi blir kastet ut, og hver gang vi logger inn sÃ¥ blir det generert en ny PIN. Dette var en litt irriterende del av oppdraget, ettersom denne servicen var sÃ¥ ustabil. NÃ¥r man fÃ¸rst kom inn, sÃ¥ var det mulig at man allerede hadde sendt neste kode pga. opphopning av feilmeldinger, og da fikk man syntaksfeil pÃ¥ neste bit og ble kastet ut. Selv om vi utelukkende sender samme brukernavn hver gang, fÃ¥r vi ogsÃ¥ ofte `That username is not recognized`.

Men etter noen minutter med bruteforcing, sÃ¥ kommer vi endelig inn, og fÃ¸rste linje er flagget. Etter dette blir vi bedt om Ã¥ sende kommandoer i hex-format. Innlevert flagg gir det siste hintet

``` 
Godt jobbet! NÃ¥ mÃ¥ du bare hjelpe gisselet med Ã¥ komme seg ut av bygningen!
```



### 2.3_scada_gissel

Den siste oppgaven var litt vag. Vi har allerede etablert at vi kan komme oss inn via bakdÃ¸ren til SCADA-systemet via PIN-bruteforce. I notatene fra `2.1_beslag_3` fikk vi ogsÃ¥ URL til en programfil, som forsÃ¸ker Ã¥ koble seg til et system for Ã¥ sende kommandoer. Denne er inkompatibel med bakdÃ¸ren pga. krav om brukernavn/PIN, men formatet den sender data pÃ¥ er `\x02 <antall bytes som fÃ¸lger><dÃ¸r-ID-i-ASCII>` f.eks. `\x02\x040005` for dÃ¸ren med ID "0005". En slik melding er det vi skal sende til bakdÃ¸ren, og dette Ã¥pner opp en av dÃ¸rene. Ved Ã¥ fÃ¸lge med i webgrensesnittet pÃ¥ TOR, eller ved Ã¥ lage en egen websocket-klient, sÃ¥ kan vi fÃ¸lge med pÃ¥ at dÃ¸rene Ã¥pnes, stÃ¥r oppe litt, og sÃ¥ lukkes og lÃ¥ses.

Ved Ã¥ fuzze litt input, sÃ¥ er det tydelig at de aksepterer ganske mange typer input, sÃ¥ lenge lengdebyten er korrekt. Men det skjer ikke noe nevneverdig hvis IDen gÃ¥r til en ikke-eksisterende dÃ¸r, eller refererer en av sensorene. "\x00" i starten ser ogsÃ¥ ut til Ã¥ stenge dÃ¸rer (rÃ¸d), og "\x01" ser ut til Ã¥ lÃ¥se de opp (gul). Selv om jeg looper steng-kommandoen til alle dÃ¸rene, sÃ¥ er det fortsatt noen dÃ¸rer som gÃ¥r opp med jevne mellomrom, sÃ¥ det er ikke mulig Ã¥ stenge inne hva eller hvem enn det er som rusler rundt inne der. Hver gang jeg ryker pÃ¥ en feiltilstand under fuzzingen, blir jeg kastet ut og mÃ¥ gjennom mange runder med ny bruteforcing fÃ¸r jeg kommer meg inn igjen, sÃ¥ jeg tester ikke veldig mye her. Jeg har satt opp en enkel klient som ber om input, og enten formatterer denne riktig for meg, eller tolker det som ren hex om den starter med `h`.

```python
def get_input(r):
    while True:
        inp = input("Door? >")
        if not inp.strip(): continue
        if inp.startswith("h"):
            pload = inp[1:].rstrip().encode()
            r.sendline(pload)
        else:
            door = format(int(inp), "04d")
            if door not in door_list.keys():
                print(f"{door} not in list")
                continue
            pload = b"\x02\x04" + door.encode()
            r.sendline(pload.hex())
        print(r.recv())
```

Ved Ã¥ lÃ¥se opp (men ikke Ã¥pne) dÃ¸ra til cellen, sÃ¥ ser vi at den Ã¥pner seg opp etter en kort stund (gÃ¥r fra gul til grÃ¸nn). Dette er gisselet som Ã¥pner dÃ¸ren selv! MÃ¥let er Ã¥ lede gisselet til exit pÃ¥ kartet, men det er noen hindringer i veien:

- DÃ¸rene har ikke ekstremt logiske navn, i alle fall ikke ved fÃ¸rste Ã¸yekast. De er gitt av et slags koordinatsystem, men med dÃ¸r-posisjon og rom-nummer som en ekstra identifikator. Jeg valgte meg ut en rute og identifiserte navnene pÃ¥ alle dÃ¸rene for Ã¥ komme dit.
- Man mÃ¥ vente pÃ¥ at gisselet faktisk gÃ¥r til neste dÃ¸r, og lÃ¥se den opp om og om igjen til gisselet gÃ¥r gjennom.
- Det er noen vakter eller detektorer som ender opp med at gisselet gÃ¥r rett tilbake til cella.
- Gisselet og vaktene er ikke synlig i oversikten. Det eneste man ser er dÃ¸rer og detektorer.

Ved Ã¥ observere detektorene sÃ¥ er det derimot mulig Ã¥ time det slik at gisselet kommer seg ut, uten Ã¥ stÃ¸te pÃ¥ sÃ¥ mye motstand. Jeg valgte dÃ¸rene `5, 513, 1325, 1925, 1928, 2833, 3334, 9934` (hvor fÃ¸rste og siste er celledÃ¸r og exit), noe som blir ruten gitt av de grÃ¸nne dÃ¸rene her (minus en av de)

![https://cdn.discordapp.com/attachments/677074936203837440/789800907175886858/unknown.png](unknown.png)



Disse ble lÃ¥st opp 1 og 1 i rekkefÃ¸lge, inntil jeg sÃ¥ at de ble Ã¥pnet og passert. Deretter lÃ¥ste jeg opp neste osv. Etter noen forsÃ¸k, sÃ¥ dukker det plutselig opp et flagg i nettleseren.

```
Gratulerer! Du klarte Ã¥ frigi gisselet, og har lÃ¸st Ã¥rets oppdrag!
I en jobb i Etterretningstjenesten vil du fÃ¥ mulighet til Ã¥ bidra til Ã¥ lÃ¸se
et viktig samfunnsoppdrag med ekte situasjoner og "skarpe" oppdrag.

Vi har laget denne CTF-en for Ã¥ tiltrekke oss sÃ¸kere til vÃ¥rt talentprogram
i 2021.
```

Samt noe informasjon om hvordan man sÃ¸ker seg inn til E-tjenesten.



## 3. Utfordringer

### 3.1 Utfordringer lett

#### 3.1.1_clmystery

Kopi av fjorÃ¥rets oppgave. LÃ¸st likt.

#### 3.1.2_fibonacci

```
Klarer du Ã¥ regne ut fibonacci raskt nok?

Adresse: tcp://fibonacci:7600
```

Her bes det om Fibonacci-tall nummer N, i flere runder, og man har ganske kort tid pÃ¥ Ã¥ svare riktig. N er et relativt lite tall, sÃ¥ vi kan enkelt prekalkulere en rekke med tall og plukke blant de

```python
from pwn import *
import re

context.log_level = "debug"

f = [0, 1]
for i in range(1000):
    f.append(f[-1] + f[-2])

r = remote("fibonacci", 7600)
while True:
    data = r.recv()
    print(data)
    num = int(re.findall(b"\d+", data)[0])
    print(num)
    r.send(str(f[num+1]))
r.interactive()
r.close()
```



#### 3.1.3_math_1

```
Jeg har laget en matematikk-tjeneste.
Vil du prÃ¸ve Ã¥ logge inn pÃ¥ systemet?

Adresse: http://math:7070

PS: Det er 2(TO) flagg i denne oppgaven
```

Enkel `curl http://math:7070/` gir at det finnes en `/flag_1` og en `flag_2`. Ved Ã¥ requeste `/flag_1` fÃ¥r man fÃ¸rste flagget.

#### 3.1.3_math_2

NÃ¥r vi requester `/flag_2` fÃ¥r vi beskjed om at `User-Agent`-headeren skal vÃ¦re `User-Agent: Math Calculator (Python 3)`. NÃ¥r denne settes, sÃ¥ fÃ¥r vi utdelt en cookie og blir sendt til `/challenge`. PÃ¥ `/challenge`-endpointet er det eneste inneholdet et mattestykke av formatet `824928+777334`. NÃ¥r vi sÃ¥ POSTer svaret tilbake, sÃ¥ kommer det enda en mattestykke Ã¥ lÃ¸se osv.

```python
from requests import session

s = session()
s.headers.update({"User-Agent": "Math Calculator (Python 3)"})

curr = s.get("http://math:7070/challenge").text
print(curr)

while True:
    curr = s.post("http://math:7070/challenge", data=str(eval(curr))).text
    print(curr)
```

Etter 30 oppgaver sÃ¥ kommer flagget.

##### P.S.

Serveren pÃ¥ denne kjÃ¸rer `bottlepy`, noe som betyr at cookiene i denne oppgaven benytter Python pickles, hvor de tolkes som f.eks. `('user_id', '7121fe7bff4c1bff')` pÃ¥ serversiden. De er derimot ogsÃ¥ signert med en hmac, men ved Ã¥ gjette hva secret til hmac er, sÃ¥ er det mulig Ã¥ signe vilkÃ¥rlige cookies og fÃ¥ RCE under pickle deserialization.

#### 3.1.4_rusty_reversing_easy

Denne oppgaven var fÃ¸rst bugget, og passordet virket ikke. Intensjonen virket Ã¥ kun vÃ¦re Ã¥ Ã¥pne programmet i en debugger, breake etter input leses inn, og sÃ¥ oppdage at den sammenligner med `this_super_secret_password_should_not_be_guessable` for sÃ¥ Ã¥ dekryptere flagget og printe det ut. Men dette virket ikke fÃ¸r den ble fikset. LÃ¸sningen var Ã¥ bare lure sammenligningen, ved Ã¥ sette registerne lik hverandre fÃ¸r compare.

`etj{rusty_binaries_are_not_thaaat_difficult_right}`



### 3.2. Utfordringer middels

#### 3.2.1_coordinate

![coordinate](coordinate.png)



Denne oppgaven har 4 deler, men kommer bare med Ã©n bildefil. Navnene hinter derimot litt til hvor vi bÃ¸r lete.

a(lpha): Ved Ã¥ se pÃ¥ alpha-layer til bildet, er det en QR-kode gjemt i den

![alpha](alpha.png)

denne dekodes til en URL til `w3w://daytime.hacking.above` som er en mÃ¥te Ã¥ oppgi en koordinat pÃ¥, via 3 ord. Disse ordene har 2 mulige lokasjoner i verden, hvor en av de er i Norge, nÃ¦rmere bestemt `Lutvann` - som ogsÃ¥ er flagget.

b(lue): Det blÃ¥ laget inneholder en del koordinater, nÃ¥r vi enten leser av bildet, eller henter ut `b8,b,lsb,xy` med zsteg.

```
[37.4040208986156, -122.11557126842482]
[38.88824944889722, -77.02301190382201]
[34.17304019448849, -117.88486574343878]
[26.16538153242349, -80.31681550621417 ]
[52.540198575411445, 13.626773749372456]
[53.51014017498718, -2.395029415893364]
[41.59016842165888, -93.6275330132897]
[37.80074583736261,-122.45645702947891]
```

ved Ã¥ se pÃ¥ disse lokasjonene, sÃ¥ danner det seg fort et mÃ¸nster; de peker pÃ¥ bygninger eller ting som ser ut som bokstaver. I rekkefÃ¸lge fra Ã¸verst til nederst, sÃ¥ staver det ordet `FONTSIZE`, som er flagget.

r(ed):

Ser man nÃ¸ye pÃ¥ det originale bildet, sÃ¥ er det noen tydelige, rÃ¸de pixler ca. pÃ¥ midten av det fÃ¸rste tallet, helt Ã¸verst. X-posisjonen til disse pixlene, lest fra venstre mot hÃ¸yre, og fra topp mot bunn, danner ASCII-strengen `subpixel`.

g(reen):

Den mest kompliserte for meg. Ved Ã¥ hente ut `b8,g,lsb,xy` med zsteg, sÃ¥ fÃ¥r vi en lang rekke med koordinater over et 3-dimensjonalt omrÃ¥de. NÃ¥r jeg forsÃ¸kte Ã¥ plotte dette, sÃ¥ fikk jeg bare stÃ¸y, helt til jeg forsÃ¸kte scatter plot i stedet for wireframe. Etter Ã¥ ha linet opp kameraet nÃ¸yaktig, sÃ¥ er det mulig Ã¥ tyde ordet `focal point` som er flagget.

![green](green.png)

#### 3.2.2_minesweeper

```
I denne oppgaven skal du lage en minesweeper-klient som automatisk lÃ¸ser brett den fÃ¥r fra en minesweeper-server.

Du mÃ¥ lÃ¸se 10 brett pÃ¥ rad med varierende vanskelighetsgrad. Det er mulig Ã¥ oppnÃ¥ totalt 3 flagg pÃ¥ denne oppgaven.
...
```

Denne oppgaven var blant de vanskeligste for meg, og den siste jeg fullfÃ¸rte. Man skal kommunisere med protobuf over en socket, og spille minesveiper pÃ¥ den mÃ¥ten. Man har 3600 sekunder pÃ¥ Ã¥ lÃ¸se level 1, og sÃ¥ 10 sekunder per level fra 2-8 og kun 5 sekunder pÃ¥ level 9 og 10. Man fÃ¥r et flagg for level 1, 8 og 10.

Jeg skrev en solver for minesveiper basert pÃ¥ https://github.com/mrgriscom/minesweepr/. Denne solveren bruker en regel-basert tilnÃ¦rming, hvor den identifiserer et aktivt omrÃ¥de og regner ut sannsynligheten for bomber langs en aktiv "front". Solveren stÃ¸tter ikke Python 3, og det var ganske mye arbeid Ã¥ porte denne over.

For hver runde, sÃ¥ 

- Oppdaterer jeg den interne tilstanden med 100% sikre bomber
- Sjekker om antall sikre bomber = antall forventede bomber, og avslutter om det er tilfelle
- Klikker pÃ¥ alle felter med 0% sannsynlighet for bombe
- Klikker pÃ¥ felter som tilstÃ¸ter et felt med "0" pÃ¥.

Sistnevnte er normalt sett noe spillklienten gjÃ¸r automatisk for en, ved Ã¥ ekspandere klikket til fÃ¸rste tall stÃ¸rre enn 0, samt markere alle '0' som en blank rute. Men her mÃ¥tte dette gjÃ¸res manuelt.

Etter level 8, sÃ¥ dukker det opp situasjoner hvor det ikke lengre er 100% sannsynlig for at noe er bombe eller ikke. PÃ¥ det tidspunktet mÃ¥ jeg velge den som har lavest sannsynlighet for Ã¥ vÃ¦re bombe, og sÃ¥ krysse fingrene. Etter et par forsÃ¸k kommer flagget ut.



#### 3.2.3_transfer

```
### Del 1

Vi har funnet denne nettverksdumpen som benytter en ukjent protokoll.
Kan du Ã¥ tilbakevikle protokollen for Ã¥ forstÃ¥ hva slags data som overfÃ¸res?

Fil: capture.pcapng

### Del 2

Vi kan nÃ¥ serveren som var i nettverksdumpen. Kan du Koble til serveren og finne noe interessant pÃ¥ serveren?

Adresse: tcp://transfer:1334'
```

Ganske rett-fram oppgave, men som krever analyse. Vi fÃ¥r en trafikklogg og delvis sensurert informasjon om en protokoll. MÃ¥let er Ã¥ gjette det resterende og dekode trafikken, og sÃ¥ lage en klient som gjÃ¸r det samme.

Etter noe analyse av pakkene, sÃ¥ er det tydelig at sekvensnumrene Ã¸ker med 1, men kun nÃ¥r serveren sender en melding. AltsÃ¥ skal vi bare kopiere det serveren sender til oss.

Sekvensen ser ut til Ã¥ vÃ¦re noe sÃ¥nt som:

- Client: Connect
- Server: Connect OK, auth?
- Client: Auth guest:guest
- Server: Key
- Client: Okay
- Server: Algorithm: 'RC4'

Etter meldingen om algoritmen, sÃ¥ blir alle data i trafikken kryptert. EtterpÃ¥ sender klienten en listdir()-request, og fÃ¥r som svar

```
FLAG_1
FLAG_2

```

hvorpÃ¥ den sender en readfile()-request med argument `FLAG_1`, som printer ut flagget. Etter dette sÃ¥ leses og skrives det flere filer

```
380b16455cd3072b Unk-5 kake.txt 12
380b16455cd3072c Success b'' 0
380b16455cd3072c Unk-7 Torsk er en hest som skyter festen 48
380b16455cd3072d Success b'' 0
380b16455cd3072d Unk-6 b'' 0
380b16455cd3072e Success Torsk er en hest som skyter festen 48
380b16455cd3072e Unk-7 Kake er en hest som smaker torsk 44
380b16455cd3072f Success b'' 0
380b16455cd3072f Unk-6 b'' 0
380b16455cd30730 Success Kake er en hest som smaker torsk 44
```



Del 2 bestÃ¥r i Ã¥ gjenskape den samme sekvensen, men nÃ¥ med "FLAG_2" som argument i stedet.

Se filen [transfer.py](transfer.py) for et eksempel pÃ¥ en implementasjon.


#### 3.2.4_rusty_reversing_medium

Denne oppgaven har samme konseptet som rusty_reversing_easy. Man skal taste inn et passord. Vi har symboler i ELF-filen, og inne i en av funksjonene kalt fra main ser vi noe sÃ¥nt som det her

![image-20201227181355246](image-20201227181355246.png)

og dette skjer to ganger. AltsÃ¥ er det bare to buffere som XORes sammen, og inne i disse er det antageligvis noe interessant.

Blant rodata finner vi verdiene som brukes

![image-20201227181534387](image-20201227181534387.png)

Ved Ã¥ XORe sammen disse, fÃ¥r vi fÃ¸rste del av passord og flagget. Det er ogsÃ¥ mulig Ã¥ sette breakpoint pÃ¥ `0x571D`, like etter at passordet er dekodet, og sÃ¥ gi en tilfeldig input.

![image-20201227185204869](image-20201227185204869.png)



```
Enter password: the_secret_password_is_secret_and_hidden
Flag: etj{rust_sure_creates_long_and_weird_function_names}
```





### 3.3 Utfordringer vanskelig

#### 3.3.1_euler

Vedlagt er en PDF med mange oppgaver i. Alle er relatert til noe arbeid som Euler har vÃ¦rt involvert i. Oppgavene var ikke ekstremt vanskelige, men det var rimelig mange av de.

##### 1) Euler![image-20201227190358006](image-20201227190358006.png)

Her er det bare Ã¥ regne ut. Notasjonen i fÃ¸rste linje er binomial, Î¦-funksjonen er Euler's totient og E-funksjonen er Euler-polynomer. De resterende er vel pensum pÃ¥ ungdomsskolen. Resultatet blir `Kunstkammer`, som er flagget.

##### 2) Sykler 

 `Euler fant ingen, men William Rowan hadde ingen problemer med Ã¥ finne en.` Vedlagt er en lang graf med mange noder pÃ¥, og et vidt spenn med tilkoblinger mellom nodene. Det hintes til `William Rowan Hamilton`, som blant annet er kjent for Ã¥ ha forsket pÃ¥ konseptet Hamiltonvei (Hamilton Path), eller Hamilton Cycle. En slik vei, er en vei som starter i en node, besÃ¸ker *alle* nodene kun Ã©n gang, og slutter der den begynte. Ã… finne en slik vei i en vilkÃ¥rlig graf, er et NP-komplett problem, men det gÃ¥r an Ã¥ fÃ¥ levelige algoritmer vha. f.eks. backtracing.

Jeg lÃ¸ste denne ved Ã¥ navngi hver enkelt node med en id, og sÃ¥ transkribere hver enkelt tilkobling den hadde. Det var en grusom jobb med veldig stort potensiale for Ã¥ gjÃ¸re feil. Til slutt satt jeg igjen med en tabell som sÃ¥ slik ut

```python
g3.graph = [#0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
            [0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 0
            [1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 1
            [0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 2
            [0,0,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 3
            [0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 4
            [0,0,0,0,1,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 5
            [0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 6
            [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 7
            [0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 8
            [0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 9
            [0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #10
            [0,0,0,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #11
            [0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #12
            [0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0], #13
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0], #14
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #15
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #16
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0], #17
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #18
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], #19
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #20
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], #21
            [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #22
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0], #23
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1], #24
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0], #25
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0], #26
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0], #27
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0], #28
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0], #29
            [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0], #30
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0], #31
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,0,0], #32
            [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0], #33
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0], #34
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,0], #35
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0], #36
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,1,0,0,0,0], #37
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,1,0,0,1,0], #38
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0], #39
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #40
           ]
```

og brukte en naiv algoritme for Ã¥ regne ut veien. Til slutt sÃ¥ mappet jeg hver node i sykelen til en bokstav, slik som i grafen. Ut kom det noen ord som ikke var i helt riktig rekkefÃ¸lge, men de var leselig nok til at jeg klarte Ã¥ gjette resten: `viten om verden for vern av norge`, som er mottoet til E-tjenesten.

##### 3) Finn n

Siste oppgaven inkluderte et program kalt `h`, som tok inn et tall og spyttet ut to tall. MÃ¥let er Ã¥ finne et tall `n` slik at outputen er en av de fÃ¸lgende:

```
a) h(n) = 8, 8
b) h(n) = 217772874500023635365563422386019273512381236824318290514357322123165713825792, 636647330747919895136525940302294632068470331232708261863503953920000000000000
c) h(n) = 9000000000000000000000000000000000000000000000000000000000, 3756326117848493706034345777213934145547380150921415411200
d) h(n) = 200000000000001220000000000000120, 99999922911895859181617256996352 (hint: n = p Â· q)
```

Etter Ã¥ ha prÃ¸vd noen tall i stigende rekkefÃ¸lge, sÃ¥ det ut som om resultatet dannet OEIS A152455, som beskrives som  `a(n) = minimal integer m such that there exists an m X m integer matrix of order n`. Det fÃ¸rste tallet som kommer ut, er derimot totienten til tallet, og for tall med fÃ¥ faktorer sÃ¥ er det et begrenset antall tall som er lik en gitt totient. Wolframalpha kan faktisk lÃ¸se de fleste av disse oppgavene, ved Ã¥ be den lÃ¸se `phi(n)=x` for et tall x. For b) og c) sÃ¥ krÃ¦sjer det derimot pga. kjÃ¸retid, men faktoriseringen av tallet i b) er `2^100 Â· 3^99` og er derfor enkel Ã¥ lÃ¸se, og for c) sÃ¥ kan vi observere noen mÃ¸nster i antall lÃ¸sninger ved Ã¥ lÃ¸se for f.eks. 9000 i stedet.

LÃ¸sningene blir som fÃ¸lger:

a) 15

b) 653318623500070906096690267158057820537143710472954871543071966369497141477376 (`(2*3)^100`)

c) 9000000000000000000000000000000000000000000000000000000001

d) 200000000000001250000000000000183 (`10000000000000061 * 20000000000000003`)



#### 3.3.2_rusty_reversing_hard

Denne gangen har vi ingen symboler. Breakpoints ser ut til Ã¥ ikke virke helt som forventet. Heldigvis er programmet veldig likt medium-oppgaven. Vi hopper inn pÃ¥ ca. samme sted som sist (0x571D) og scroller litt oppover i koden. Der er det en funksjon som ligner veldig pÃ¥ libc sin strcmp, sÃ¥ vi setter et breakpoint der

![image-20201227190057816](image-20201227190057816.png)



![image-20201227190137610](image-20201227190137610.png)

og ut kommer passordet.

```
root@f5ed25202d37:/ctf/work# ./rust_hard
Enter password: sometimes_a_password_is_not_very_long_but_this_one_actually_is_super_duper_long
Flag: etj{i_did_not_know_rust_did_dynamic_dispatch_with_such_weird_vftable_placement}
```



### 3.4 Utfordringer umulig

#### 3.4.8_transfer.root

I Transfer-oppgaven, sÃ¥ kan man ved Ã¥ identifisere alle datatypene se at de inkluderer

- SetFilename(str)
- ChangeDirectory(str)
- ReadFile()
- WriteFile(str)
- ListDir()

Hvor de funksjonene som ikke tar parametere opererer pÃ¥ filnavn eller directory som er satt. Vi kan altsÃ¥ finne og lese filer andre steder enn i `/tmp/transfer`, og lese ut f.eks. `/root/FLAG` som gir noen bonuspoeng. Det er derimot noen begrensninger pÃ¥ lese-funksjonen, enten i lengde pÃ¥ data eller for string-representasjonen. Det var ikke mulig Ã¥ lese ut `transfer`-binary, som et eksempel.